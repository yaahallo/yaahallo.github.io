<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title></title>

      <!-- css -->
      <link rel="stylesheet" href="/reset.css">
      <link rel="stylesheet" href="/feather.css">

      <!-- fonts -->
      <link href="https://fonts.googleapis.com/css?family=Merriweather:300,400|Montserrat:400,700" rel="stylesheet">

      <!-- js -->
      <script src='/js/images.js'></script>
      <script src='/js/main.js'></script>

      

      

      
      
    </head>

    <body>

    <a href="/">
      <div class='header-image' style='background-image: url(&#x2f;15_fox.png);'></div>
    </a>

    
<div class='container'>
  <section class="post">
  	<div class="title-and-info">
    	<h2>An Exploration of C++&#x27;s &quot;Other Operators&quot;</h2>
    	<div class="info">
    		<span>14 minute read</span>
    		
    			<span class='divider'/>
    			<span>03 April 2019</span>
    		
    		
    		
    	</div>
    </div>
  	<article>
  		<h1 id="c-other-operators">C++ Other Operators</h1>
<p>Its dangerous to go alone, take this.</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/operator_other">https://en.cppreference.com/w/cpp/language/operator_other</a></li>
</ul>
<p>Feel free to reference this while you're reading, I think its a relatively interesting read, but don't worry about it to much because I include the most relevant sections inline in this post. What follows is going to be a series of <em>fun</em> facts about C++'s other operators, how I feel about them, and how they compare to similar language features in Rust <em>(of course)</em>.</p>
<p>I plan on going in order through the list of three operators from the above page, the function call operator, the comma operator, and the conditional operator (colloquially referred to as ternary conditional). The first story discusses the implications of <a href="https://en.cppreference.com/w/cpp/language/eval_order">order of evaluation</a> in C++. It is a bit of an outlier and doesnt factor in much to the rest of the talk but I felt I couldn't leave one of the operators out. The second tale explores the behavors of the often used and far less often understood comma operator. The last parable is about the conditional operator. It is the genesis of this post, and briefly visit the crazy ball of wax known as <a href="https://en.cppreference.com/w/cpp/language/value_category">value categories</a> in C++ and then end up running away as quickly as it can.</p>
<p>Lets get right into it!</p>
<h2 id="function-call-operator">function call operator</h2>
<p>This story starts with a simple example from <code>Effective Modern C++</code> chapter 21.</p>
<pre style="background-color:#eff1f5;">
<span style="color:#bf616a;">processWidget</span><span style="color:#4f5b66;">(std::</span><span style="color:#bf616a;">shared_ptr</span><span style="color:#4f5b66;">&lt;Widget&gt;(</span><span style="color:#b48ead;">new</span><span style="color:#4f5b66;"> Widget), </span><span style="color:#a7adba;">// potential
              </span><span style="color:#bf616a;">computePriority</span><span style="color:#4f5b66;">());                  </span><span style="color:#a7adba;">// resource
                                                   // leak!
</span></pre>
<p>Potential resource leak? Wat. Let us refer to the documentation for the function call operator!</p>
<pre style="background-color:#eff1f5;">
<span style="color:#4f5b66;">E ( A1, A2, A3,... )

- The expression E as well as all expressions A1, A2, A3, etc, provided as
  arguments are evaluated in arbitrary order, unsequenced with respect to each
  other. (until C++17)
- The expression E is sequenced before each of the expressions A1, A2, A3 as
  well as default arguments, if any. The argument expressions are evaluated in
  arbitrary order, indeterminately sequenced with respect to each other. (since C++17)
</span></pre>
<p>Unsequenced? Indeterminately Sequenced? What does that mean? Lets dig deeper.</p>
<pre style="background-color:#eff1f5;">
<span style="color:#4f5b66;">- If A is not sequenced before B and B is not sequenced before A, then two possibilities exist:
  - evaluations of A and B are unsequenced: they may be performed in any order
    and may overlap (within a single thread of execution, the compiler may
    interleave the CPU instructions that comprise A and B)
  - evaluations of A and B are indeterminately sequenced: they may be performed
    in any order but may not overlap: either A will be complete before B, or B will
    be complete before A. The order may be the opposite the next time the same
    expression is evaluated.
</span></pre>
<p>Okay got it, the expressions in the function call can be reordered however the compiler likes. In this case those expressions are <code>new Widget</code>, <code>std::shared_ptr&lt;Widget&gt;(ptr from previous expression)</code>, and <code>computePriority()</code>. The real problem occurs if one of the expressions can throw an exception. In this case we'd be worried about computePriority(). If the compiler orders the execution such that it first allocates the widget, then calls computePriority prior to constructing a shared pointer to manage the new Widget's memory, and the computePriority call throws, we will never construct a shared pointer to manage the memory for our Widget and we unknowningly miss out on all the wonderful RAII style memory management we thought we'd signed up for.</p>
<p>But what are we supposed to do you might ask. Lets start with the name of the chapter this nugget of wisdom came from, <code>Prefer std::make_unique and std::make_shared to direct use of new</code>. Oh, okay then.</p>
<pre style="background-color:#eff1f5;">
<span style="color:#bf616a;">processWidget</span><span style="color:#4f5b66;">(std::</span><span style="color:#bf616a;">make_shared</span><span style="color:#4f5b66;">&lt;Widget&gt;(),          </span><span style="color:#a7adba;">// no potential
              </span><span style="color:#bf616a;">computePriority</span><span style="color:#4f5b66;">());                  </span><span style="color:#a7adba;">// resource leak
</span></pre>
<p>Now I'm not 100% sure why the <code>until C++17</code> section from before about unsequenced cpu instructions overlapping doesn't make it so that this could still fail but I'm quite confident that it doesn't. I assume it has something to do with sequency guaruntees in C++ and how they relate to function boundaries and observable sideeffects but I'm not positive. Maybe if they get inlined it could get hairy, who knows, probably not. I'm curious so I'll probably look it up later but for now its unimportant. Let us continue.</p>
<p>By using <code>make_shared</code> rather than <code>new</code> and a constructor we turn two expressions into one as far as the function call operator is concerned. It will probably make sure not to interleave a throw from another expression with our expression so now we either get to run make_shared and then throw after, in which case we get our widget deallocated, or we throw before make_shared, and we never allocate it in the first place. Perfect!</p>
<p>So whats the moral of the story? I'm inclined to say its <code>avoid new whenever possible</code> but thats just me. If you need dynamic memory you should probably always use some generic class that abstracts the memory management for you. Thats literally the only way to allocate dynamic memory in safe Rust and I hear they're pretty good about not fucking up their memory managemnet. Particularly with shared_ptr theres other benefits such as <code>make_shared</code> only requiring one dynamic memory allocation where as the constructor plus new require two. Though this can have some undesirable side effects when you mix in large memory allocations and weak_ptrs. If you want to learn more about the intricacies of smart pointers in C++ I cannot recommend <code>Effective Modern C++</code> enough.</p>
<h2 id="comma-operator">comma operator</h2>
<p>This next tale is a fun one that starts to really touch the main topic, <a href="https://en.cppreference.com/w/cpp/language/statements">statements</a> vs <a href="https://en.cppreference.com/w/cpp/language/expressions">expressions</a> in C++ and Rust. Let us start with a few examples of what is and is not the comma operator.</p>
<pre style="background-color:#eff1f5;">
<span style="color:#b48ead;">int</span><span style="color:#4f5b66;"> a = </span><span style="color:#d08770;">1</span><span style="color:#4f5b66;">, b = </span><span style="color:#d08770;">2</span><span style="color:#4f5b66;">;                       </span><span style="color:#a7adba;">// nope
</span><span style="color:#bf616a;">processWidget</span><span style="color:#4f5b66;">(a, b);                    </span><span style="color:#a7adba;">// also nope
</span><span style="color:#bf616a;">processWidget</span><span style="color:#4f5b66;">((a, b));                  </span><span style="color:#a7adba;">// yup!

</span><span style="color:#b48ead;">for</span><span style="color:#4f5b66;">(</span><span style="color:#b48ead;">int</span><span style="color:#4f5b66;"> i = </span><span style="color:#d08770;">0</span><span style="color:#4f5b66;">, j = </span><span style="color:#d08770;">1</span><span style="color:#4f5b66;">; i &lt; </span><span style="color:#d08770;">10</span><span style="color:#4f5b66;">; i++, j++) </span><span style="color:#a7adba;">// no and yes
    </span><span style="color:#4f5b66;">;

</span><span style="color:#b48ead;">int</span><span style="color:#4f5b66;"> i, j;
</span><span style="color:#b48ead;">for</span><span style="color:#4f5b66;">(i = </span><span style="color:#d08770;">0</span><span style="color:#4f5b66;">, j = </span><span style="color:#d08770;">1</span><span style="color:#4f5b66;">; i &lt; </span><span style="color:#d08770;">10</span><span style="color:#4f5b66;">; i++, j++)     </span><span style="color:#a7adba;">// yes and yes! (I think)
    </span><span style="color:#4f5b66;">;
</span></pre>
<p>Lets break these down.</p>
<p>The first one is a <a href="https://en.cppreference.com/w/cpp/language/declarations">simple declaration statement</a>, their words, not mine. Also I want to take a second to point out how annoyed I was by the fact that in their list of declaration categories, the one for variables was listed last and was called <code>simple declaration</code>. It took me far too long to find and I've decided I don't like it (the documentation). Anyways, the commas in that statement are separators in what is called the <code>init-declarator-list</code>.</p>
<p>The next one is a function call, the commas are part of the function call operator. If we go back to the documenation on that bad boy we can find this extra piece of wisdom.</p>
<pre style="background-color:#eff1f5;">
<span style="color:#4f5b66;">A1, A2, A3,... is a possibly empty list of arbitrary expressions, except the comma operator is not allowed at the top level to avoid ambiguity.
</span></pre>
<p>Okay so the comma operator is banned in function calls, lame but okay, I guess it makes sense. Whats with the next guy though? In order to properly explain why that <em>is</em> the comma operator we must first explore the definition of the comma operator.</p>
<pre style="background-color:#eff1f5;">
<span style="color:#4f5b66;">E1 , E2

In a comma expression E1, E2, the expression E1 is evaluated, its result is discarded (although if it has class type, it won&#39;t be destroyed until the end of the containing full expression), and its side effects are completed before evaluation of the expression E2 begins (note that a user-defined operator, cannot guarantee sequencing) (until C++17).

The type, value, and value category of the result of the comma expression are exactly the type, value, and value category of the second operand, E2. If E2 is a temporary expression (since C++17), the result of the expression is that temporary expression (since C++17). If E2 is a bit-field, the result is a bit-field.
</span></pre>
<p>Pay attention to that bit about value category because thats going to come up more later, but for now lets focus on the comma operator, I hope it reminds you of <code>;</code> (not an operator). There are two key facts here, first, the entire comma separated series of expressions is itself an expression, where as a semicolon separated series of expressions is a series of <a href="https://en.cppreference.com/w/cpp/language/expressions">expression statements</a>. Both <code>,</code> and <code>;</code> are similar in that they seperate series of expressions, the difference is that one does so by turning them into statements, and the other does so by turning them into an expression that evaluates to the value of the last expression. The second important fact is that any expression that is wrapped in parenthesis is itself considered to be a <a href="https://en.cppreference.com/w/cpp/language/expressions">primary expression</a>.</p>
<p>So when we say <code>processWidget((a, b))</code> it is as if we had said <code>a; processWidget(b)</code> (dont quote me on this). In this case <code>a</code> does nothing, its an lvalue identifier to a variable, presumably, and the expression evaluates to itself and the value is discarded, literally less than useless, I hope I didn't mislead you with my example (jk I totally hope I confused you). So you end up with calling <code>processWidget</code> with a single argument <code>b</code>'s type, so its not even calling the same function as the previous example, fun. But now that we know that the rest should be easy.</p>
<p>The for loop statement starts with a declaration statement, followed by a boolean expression, followed by a single expression, but we want to do two things in this part of the for loop, so we use the comma operator to let us sneak two expressions in where one is expected, brilliant! This is also the use case pretty much everyone is familiar with.</p>
<p>The last example is hopefully obvious by now, the declaration is moved outside of the loop, and instead the first section of the for loop contains a comma operator separated list of assignment expressions and the rest is identical to the previous example.</p>
<p>I think its worth pointing out that you can implement <code>operator,</code> for your own types. It's also worth pointing out that there are a ton of ways you can shoot yourself in the foot doing this and that you probably shouldn't ever do it. For more information look <a href="https://ideone.com/cYvQrz">here</a> and then <a href="https://blog.codeisc.com/2017/12/26/cpp-comma-operator-introduction.html">here</a> and maybe even <a href="https://en.wikipedia.org/wiki/Comma_operator">here</a>.</p>
<p>Another situation where the comma operator sees legitimate use is C++11 constexpr function programming. Which has the constraint that it must only contain a single return statement (and a few other things, but whats important is that things like expression statements aren't allowed), so you can use the comma operator to sequentially execute multiple expressions where only one is expected. You know what else gets used a lot in constexpr programing for C++11? The <code>conditional operator</code>! Seriously check out the <a href="https://en.cppreference.com/w/cpp/language/constexpr">examples</a> for the documentation on constexpr, its chock-full of conditional operator expressions. And, interestingly but unsurprisingly enough, its used for the exact same reasons that the comma operator is used! Let us explore why~</p>
<h2 id="conditional-operator">conditional operator</h2>
<p>The entire reason I wanted to give this talk is really to mention this simple example my friend <a href="https://github.com/Chibin">Marbin</a> showed me a week ago.</p>
<pre style="background-color:#eff1f5;">
<span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">whyThough</span><span style="color:#4f5b66;">(</span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">a</span><span style="color:#4f5b66;">, </span><span style="color:#b48ead;">int</span><span style="color:#4f5b66;">&amp; </span><span style="color:#bf616a;">b</span><span style="color:#4f5b66;">, </span><span style="color:#b48ead;">int</span><span style="color:#4f5b66;">&amp; </span><span style="color:#bf616a;">c</span><span style="color:#4f5b66;">) {
    ( a ? b : c ) = </span><span style="color:#d08770;">1</span><span style="color:#4f5b66;">;
}
</span></pre>
<p>This is a perfectly legal expression and finding that out blew my mind. An explanation for why this works can be found in both the page for <a href="https://en.cppreference.com/w/cpp/language/value_category">value categories</a> and the page for <a href="https://en.cppreference.com/w/cpp/language/operator_other">other operators</a>. Sadly its really dense no matter which one you look at, so I will paraphrase. If both arms of a conditional operator expression are lvalues, then the entire expression is usually an lvalue as well. If you want to know why I said usually I recommend reading the documentation yourself, but for now you'll probably be fine if you just treat this simplification as truth. Disclaimer, this section of the documentation mentions lvalues, glvalues, rvalues, prvalues, xvalues, cv-qualifiers, implicit conversion sequences, and who knows what else. It's a lot to take in.</p>
<p>For those of us who barely remember or dont know what these value categories are I think it helps to know how Rust defines them, because its a lot simpler and mostly applies back to C++ (except for the million edge cases where it doesnt). In Rust there are place expressions and value expressions. These loosely correlate to lvalues and rvalues respectively in C++. Place expressions are defined as expressions that represent a memory address, value expressions are defined as !(place expression). If you have trouble remembering which one is an lvalue and which one is an rvalue, know that lvalue comes from lef-hand side value, and rvalue comes from right-hand side value. In <code>int a = 0; a = iReturnRandomInts();</code> <code>a</code> is an lvalue and the return value from <code>iReturnRandomInts</code> is an rvalue. Conveniently they're both on the correct side of the expression based on their names.</p>
<p>If you apply the definitions of place expressions and value expressions from Rust to lvalues and rvalues in C++ you'll rarely be wrong. Don't ask me what the caveats are, because I cant remember, its just too confusing for me so far. I look forward to the day when all the value categories in C++ finally sink in. For now simplified mental models will do.</p>
<p>Anyways, back to the conditional operator. Because the entire thing is an lvalue we can do things that you're only allowed to do to lvalues with it, like assign to it or take its address! I don't have any profound gotchas about this one, I just feel that its weird that conditional operator expressions aren't always rvalues. But this leads nicely into the discussion I want to have about these operators and their place in the C++ language.</p>
<h2 id="my-feelings">my feelings</h2>
<p>Long story short I don't feel like these two operators are very <code>C++</code>-like. To me they feel like aberations, and I feel as though they were added to fill in holes left behind by how the language's syntax was designed. Now's where I really start talking about Rust. Super short story time, my old boss was a bit of a Functional Programming Evangelist, and as a result I started paying attention to functional programming whenever it came up as a topic though I didn't dig into it. When I first heard about Rust I went and browsed the wikipedia article about it and thanks to my conditioning from Ian when I came upon the following blurb it burned into my mind for all of eternity.</p>
<pre style="background-color:#eff1f5;">
<span style="color:#4f5b66;">Despite the superficial resemblance to C and C++, the syntax of Rust in a deeper sense is closer to that of the ML family of languages as well as the Haskell language. Nearly every part of a function body is an expression,[26] even control flow operators.
</span></pre>
<p>In Rust, virtually everything is an expression. Just take a look at this screenshot from the Rust reference.</p>
<p><img src="https://yaah.dev/other-operators/sofew.png" alt="statements and expressions from the Rust Reference" /></p>
<p>And compare that to the list of statements in cppreference.</p>
<p><img src="https://yaah.dev/other-operators/somany.png" alt="statements from cppreference" /></p>
<p>Where C++ has compound statements Rust has block expressions. Where C++ has return statements Rust has return expressions. Where C++ has iteration statements Rust has loop expressions. You no doubt see a pattern forming. The only things in Rust that are statements are declarations, things like variables or functions, and expression statements, which are expressions followed by a semicolon. Everything else is an expression. To me it feels like the the conditional operator and comma operator in C++ were added only because they had already decided that conditions and blocks were statements, but it turns out that compounding expressions and having conditional expressions is super useful so they hacked them in after the fact. Where as Rust was able to learn from the mistakes of its forebearers and generalized all of these statements into expressions. The equivalent of <code>auto d = (a ? b : c);</code> in Rust is <code>let d = if a { b } else { c };</code> and the equivalent of <code>auto d = (E1, E2, E3);</code> is <code>let d = {E1; E2; E3 };</code>. One difference is that these block and if expressions in Rust are always value expressions, so they cannot be assigned too without using something like a macro, unlike their C++ counterparts which inherit their value category from the relevant sub expressions and can be assinged to quite easily.</p>
<p>Now in retrospect perhaps aberation is a bit of a strong word. I do not dislike these operators and the functionality they provide. I just dislike the fact that these two nice ML style syntax operators are relegated to the outskirts of the language rather than nicely integrated with its core. They feel like outliers to me and they remind me of Rust far more strongly than they remind me of C++. They make me wish I was working in Rust but for now I'm still firmly in c++ land and so I will continue to try to understand it better.</p>
<h2 id="conclusion">conclusion</h2>
<p>Quick review of what we covered.</p>
<ul>
<li>value categories (place vs value or lvalue vs rvalue)</li>
<li>indepth comparison between statements and expressions</li>
<li>the dangers of sequencing and exception safety</li>
<li>one small reason I'm in love with Rust</li>
</ul>
<p>Thank you all for reading, I hope you all enjoyed this as much as I enjoyed writing it.</p>

  	</article>
  </section>

  

</div>


    <footer>
      Feather theme by <a href="https://github.com/piedoom/feather">doomy</a>&nbsp;&nbsp;-&nbsp;&nbsp; Built with <a href="https://www.getzola.org/">Zola</a>
      
    </footer>

    </body>

</html>
